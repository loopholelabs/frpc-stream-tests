// Code generated by FRPC v0.5.1, DO NOT EDIT.
// source: test.proto

package stream_tests

import (
	"errors"
	"github.com/loopholelabs/frisbee/pkg/packet"
	"io"

	"context"
	"crypto/tls"
	"github.com/loopholelabs/frisbee"
	"github.com/rs/zerolog"

	"github.com/loopholelabs/common/pkg/queue"
	"go.uber.org/atomic"
	"sync"
)

const connectionContextKey int = 1000

func SetCloseFlag(flags uint8, close bool) uint8 {
	return flags | 0x1
}
func HasCloseFlag(flags uint8) bool {
	return flags&1 == 1
}
func SetErrorFlag(flags uint8, error bool) uint8 {
	return flags | 0x2
}
func HasErrorFlag(flags uint8) bool {
	return flags&(1<<1) == 1
}

var (
	NilDecode = errors.New("cannot decode into a nil root struct")
)

type Request struct {
	error error
	flags uint8

	InitialCount int32
}

func NewRequest() *Request {
	return &Request{}
}

func (x *Request) Error(p *packet.Packet, err error) {
	packet.Encoder(p).Error(err)
}

func (x *Request) Encode(p *packet.Packet) {
	if x == nil {
		packet.Encoder(p).Nil()
	} else if x.error != nil {
		packet.Encoder(p).Error(x.error).Uint8(x.flags)
	} else {
		packet.Encoder(p).Uint8(x.flags).Int32(x.InitialCount)
	}
}

func (x *Request) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := packet.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *Request) decode(d *packet.Decoder) error {
	if d.Nil() {
		return nil
	}
	var err error

	x.error, err = d.Error()
	if err != nil {
		x.flags, err = d.Uint8()
		if err != nil {
			return err
		}

		x.InitialCount, err = d.Int32()
		if err != nil {
			return err
		}
	} else {
		x.flags, err = d.Uint8()
		if err != nil {
			return err
		}
	}
	return nil
}

type Count struct {
	error error
	flags uint8

	Result int32
}

func NewCount() *Count {
	return &Count{}
}

func (x *Count) Error(p *packet.Packet, err error) {
	packet.Encoder(p).Error(err)
}

func (x *Count) Encode(p *packet.Packet) {
	if x == nil {
		packet.Encoder(p).Nil()
	} else if x.error != nil {
		packet.Encoder(p).Error(x.error).Uint8(x.flags)
	} else {
		packet.Encoder(p).Uint8(x.flags).Int32(x.Result)
	}
}

func (x *Count) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := packet.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *Count) decode(d *packet.Decoder) error {
	if d.Nil() {
		return nil
	}
	var err error

	x.error, err = d.Error()
	if err != nil {
		x.flags, err = d.Uint8()
		if err != nil {
			return err
		}

		x.Result, err = d.Int32()
		if err != nil {
			return err
		}
	} else {
		x.flags, err = d.Uint8()
		if err != nil {
			return err
		}
	}
	return nil
}

type Response struct {
	error error
	flags uint8

	Count int32
}

func NewResponse() *Response {
	return &Response{}
}

func (x *Response) Error(p *packet.Packet, err error) {
	packet.Encoder(p).Error(err)
}

func (x *Response) Encode(p *packet.Packet) {
	if x == nil {
		packet.Encoder(p).Nil()
	} else if x.error != nil {
		packet.Encoder(p).Error(x.error).Uint8(x.flags)
	} else {
		packet.Encoder(p).Uint8(x.flags).Int32(x.Count)
	}
}

func (x *Response) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := packet.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *Response) decode(d *packet.Decoder) error {
	if d.Nil() {
		return nil
	}
	var err error

	x.error, err = d.Error()
	if err != nil {
		x.flags, err = d.Uint8()
		if err != nil {
			return err
		}

		x.Count, err = d.Int32()
		if err != nil {
			return err
		}
	} else {
		x.flags, err = d.Uint8()
		if err != nil {
			return err
		}
	}
	return nil
}

type AnyStreamServer interface {
	close()
}

type TestService interface {
	GetNumber(context.Context, *Request) (*Response, error)

	SendNumbers(srv *SendNumbersServer) error

	GetNumbers(req *Request, srv *GetNumbersServer) error

	ExchangeNumbers(srv *ExchangeNumbersServer) error
}

type ServerMap struct {
	servers map[uint16]AnyStreamServer
	closed  bool
	mu      sync.Mutex
}

func NewServerMap() *ServerMap {
	return &ServerMap{servers: make(map[uint16]AnyStreamServer)}
}

type Server struct {
	*frisbee.Server

	nextSendNumbers   uint16
	nextSendNumbersMu sync.RWMutex

	nextExchangeNumbers   uint16
	nextExchangeNumbersMu sync.RWMutex
	streams               map[string]*ServerMap
	streamsMu             sync.RWMutex
}

func NewServer(testService TestService, tlsConfig *tls.Config, logger *zerolog.Logger) (*Server, error) {
	var s *Server
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewRequest()
		err := req.Decode(incoming.Content.B)
		if err == nil {
			var res *Response
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = testService.GetNumber(ctx, req)
			if err != nil {
				res.Error(outgoing, err)
			} else {
				res.Encode(outgoing)
			}
			outgoing.Metadata.ContentLength = uint32(len(outgoing.Content.B))
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewCount()
		err := req.Decode(incoming.Content.B)
		if err == nil {
			id := incoming.Metadata.Id
			conn := ctx.Value(connectionContextKey).(*frisbee.Async)

			s.streamsMu.RLock()
			if smap, ok := s.streams[conn.RemoteAddr().String()]; ok {
				s.streamsMu.RUnlock()
				smap.mu.Lock()
				if srv, ok := smap.servers[id].(*SendNumbersServer); ok {
					smap.mu.Unlock()
					srv.received.Push(req)
					if HasCloseFlag(req.flags) {
						srv.close()
					}
					return
				} else {
					smap.mu.Unlock()
				}
			} else {
				s.streamsMu.RUnlock()
			}
			q := queue.NewCircular[Count, *Count](100)
			q.Push(req)
			srv := &SendNumbersServer{
				context:  ctx,
				received: q,
				stale:    make([]*Count, 0),
				closed:   atomic.NewBool(false),
			}
			s.streamsMu.Lock()
			if serverMap, ok := s.streams[conn.RemoteAddr().String()]; ok {
				s.streamsMu.Unlock()
				serverMap.mu.Lock()
				serverMap.servers[id] = srv
				serverMap.mu.Unlock()
			} else {
				s.streamsMu.Unlock()
				serverMap := NewServerMap()
				serverMap.servers[id] = srv
				s.streamsMu.Lock()
				s.streams[conn.RemoteAddr().String()] = serverMap
				s.streamsMu.Unlock()
			}
			srv.recv = func() (*Count, error) {
				if srv.closed.Load() {
					srv.staleMu.Lock()
					if len(srv.stale) > 0 {
						var r *Count
						r, srv.stale = srv.stale[0], srv.stale[1:]
						srv.staleMu.Unlock()
						if errors.Is(r.error, io.EOF) {
							return nil, io.EOF
						}
						return r, nil
					}
					srv.staleMu.Unlock()
					return nil, io.EOF
				}

				readPacket, err := srv.received.Pop()
				if err != nil {
					if srv.closed.Load() {
						srv.staleMu.Lock()
						if len(srv.stale) > 0 {
							var r *Count
							r, srv.stale = srv.stale[0], srv.stale[1:]
							srv.staleMu.Unlock()
							return r, nil
						}
						srv.staleMu.Unlock()
					}
					return nil, io.EOF
				}
				if errors.Is(readPacket.error, io.EOF) {
					return nil, io.EOF
				}
				return readPacket, nil
			}
			srv.send = func(m *Response) error {
				p := packet.Get()
				p.Metadata.Operation = 11

				p.Metadata.Id = id

				m.Encode(p)
				p.Metadata.ContentLength = uint32(len(p.Content.B))
				err := conn.WritePacket(p)
				if err != nil {
					packet.Put(p)
					return err
				}
				packet.Put(p)
				return nil
			}

			go func() {
				err := testService.SendNumbers(srv)
				if err != nil {
					res := Response{error: err}
					res.flags = SetErrorFlag(res.flags, true)
					srv.CloseAndSend(&res)
				} else {
					srv.CloseSend()
				}
				s.streamsMu.RLock()
				if smap, ok := s.streams[conn.RemoteAddr().String()]; ok {
					s.streamsMu.RUnlock()
					smap.mu.Lock()
					delete(smap.servers, incoming.Metadata.Id)
					smap.mu.Unlock()
				} else {
					s.streamsMu.RUnlock()
				}
			}()
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewRequest()
		err := req.Decode(incoming.Content.B)
		if err == nil {
			id := incoming.Metadata.Id
			conn := ctx.Value(connectionContextKey).(*frisbee.Async)

			srv := &GetNumbersServer{
				context: ctx,
				closed:  atomic.NewBool(false),
			}
			s.streamsMu.Lock()
			if serverMap, ok := s.streams[conn.RemoteAddr().String()]; ok {
				s.streamsMu.Unlock()
				serverMap.mu.Lock()
				serverMap.servers[id] = srv
				serverMap.mu.Unlock()
			} else {
				s.streamsMu.Unlock()
				serverMap := NewServerMap()
				serverMap.servers[id] = srv
				s.streamsMu.Lock()
				s.streams[conn.RemoteAddr().String()] = serverMap
				s.streamsMu.Unlock()
			}
			srv.send = func(m *Count) error {
				p := packet.Get()
				p.Metadata.Operation = 12

				p.Metadata.Id = id

				m.Encode(p)
				p.Metadata.ContentLength = uint32(len(p.Content.B))
				err := conn.WritePacket(p)
				if err != nil {
					packet.Put(p)
					return err
				}
				packet.Put(p)
				return nil
			}

			go func() {
				err := testService.GetNumbers(req, srv)
				if err != nil {
					res := Count{error: err}
					res.flags = SetErrorFlag(res.flags, true)
					srv.CloseAndSend(&res)
				} else {
					srv.CloseSend()
				}
			}()
		}
		return
	}
	table[13] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewCount()
		err := req.Decode(incoming.Content.B)
		if err == nil {
			id := incoming.Metadata.Id
			conn := ctx.Value(connectionContextKey).(*frisbee.Async)

			s.streamsMu.RLock()
			if smap, ok := s.streams[conn.RemoteAddr().String()]; ok {
				s.streamsMu.RUnlock()
				smap.mu.Lock()
				if srv, ok := smap.servers[id].(*ExchangeNumbersServer); ok {
					smap.mu.Unlock()
					srv.received.Push(req)
					if HasCloseFlag(req.flags) {
						srv.close()
					}
					return
				} else {
					smap.mu.Unlock()
				}
			} else {
				s.streamsMu.RUnlock()
			}
			q := queue.NewCircular[Count, *Count](100)
			q.Push(req)
			srv := &ExchangeNumbersServer{
				context:  ctx,
				received: q,
				stale:    make([]*Count, 0),
				closed:   atomic.NewBool(false),
			}
			s.streamsMu.Lock()
			if serverMap, ok := s.streams[conn.RemoteAddr().String()]; ok {
				s.streamsMu.Unlock()
				serverMap.mu.Lock()
				serverMap.servers[id] = srv
				serverMap.mu.Unlock()
			} else {
				s.streamsMu.Unlock()
				serverMap := NewServerMap()
				serverMap.servers[id] = srv
				s.streamsMu.Lock()
				s.streams[conn.RemoteAddr().String()] = serverMap
				s.streamsMu.Unlock()
			}
			srv.recv = func() (*Count, error) {
				if srv.closed.Load() {
					srv.staleMu.Lock()
					if len(srv.stale) > 0 {
						var r *Count
						r, srv.stale = srv.stale[0], srv.stale[1:]
						srv.staleMu.Unlock()
						if errors.Is(r.error, io.EOF) {
							return nil, io.EOF
						}
						return r, nil
					}
					srv.staleMu.Unlock()
					return nil, io.EOF
				}

				readPacket, err := srv.received.Pop()
				if err != nil {
					if srv.closed.Load() {
						srv.staleMu.Lock()
						if len(srv.stale) > 0 {
							var r *Count
							r, srv.stale = srv.stale[0], srv.stale[1:]
							srv.staleMu.Unlock()
							return r, nil
						}
						srv.staleMu.Unlock()
					}
					return nil, io.EOF
				}
				if errors.Is(readPacket.error, io.EOF) {
					return nil, io.EOF
				}
				return readPacket, nil
			}
			srv.send = func(m *Count) error {
				p := packet.Get()
				p.Metadata.Operation = 13

				p.Metadata.Id = id

				m.Encode(p)
				p.Metadata.ContentLength = uint32(len(p.Content.B))
				err := conn.WritePacket(p)
				if err != nil {
					packet.Put(p)
					return err
				}
				packet.Put(p)
				return nil
			}

			go func() {
				err := testService.ExchangeNumbers(srv)
				if err != nil {
					res := Count{error: err}
					res.flags = SetErrorFlag(res.flags, true)
					srv.CloseAndSend(&res)
				} else {
					srv.CloseSend()
				}
				s.streamsMu.RLock()
				if smap, ok := s.streams[conn.RemoteAddr().String()]; ok {
					s.streamsMu.RUnlock()
					smap.mu.Lock()
					delete(smap.servers, incoming.Metadata.Id)
					smap.mu.Unlock()
				} else {
					s.streamsMu.RUnlock()
				}
			}()
		}
		return
	}
	var fsrv *frisbee.Server
	var err error
	if tlsConfig != nil {
		fsrv, err = frisbee.NewServer(table, frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		fsrv, err = frisbee.NewServer(table, frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	fsrv.ConnContext = func(ctx context.Context, conn *frisbee.Async) context.Context {
		return context.WithValue(ctx, connectionContextKey, conn)
	}
	s, err = &Server{
		Server: fsrv,
	}, nil

	fsrv.SetOnClosed(func(async *frisbee.Async, err error) {
		s.streamsMu.RLock()
		if streamMap, ok := s.streams[async.RemoteAddr().String()]; ok {
			s.streamsMu.RUnlock()
			for _, stream := range streamMap.servers {
				stream.close()
			}
			return
		}
		s.streamsMu.RUnlock()
	})

	s.nextSendNumbers = 0
	s.nextExchangeNumbers = 0
	s.streams = make(map[string]*ServerMap)
	return s, err
}

type SendNumbersServer struct {
	AnyStreamServer

	context context.Context
	recv    func() (*Count, error)
	send    func(*Response) error

	received *queue.Circular[Count, *Count]
	stale    []*Count
	staleMu  sync.Mutex
	closed   *atomic.Bool
}

func (x *SendNumbersServer) Context() context.Context {
	return x.context
}

func (x *SendNumbersServer) Recv() (*Count, error) {
	return x.recv()
}

func (x *SendNumbersServer) close() {
	x.staleMu.Lock()
	x.closed.Store(true)
	x.stale = x.received.Drain()
	x.staleMu.Unlock()
	x.received.Close()
}
func (x *SendNumbersServer) CloseSend() error {
	r := Response{error: io.EOF, flags: SetCloseFlag(0, true)}
	return x.send(&r)
}

func (x *SendNumbersServer) CloseAndSend(m *Response) error {
	m.flags = SetCloseFlag(m.flags, true)
	return x.send(m)
}

type GetNumbersServer struct {
	AnyStreamServer

	context context.Context
	recv    func() (*Request, error)
	send    func(*Count) error

	closed *atomic.Bool
}

func (x *GetNumbersServer) Context() context.Context {
	return x.context
}

func (x *GetNumbersServer) Send(m *Count) error {
	return x.send(m)
}
func (x *GetNumbersServer) CloseSend() error {
	r := Count{error: io.EOF, flags: SetCloseFlag(0, true)}
	return x.send(&r)
}

func (x *GetNumbersServer) CloseAndSend(m *Count) error {
	m.flags = SetCloseFlag(m.flags, true)
	return x.send(m)
}

type ExchangeNumbersServer struct {
	AnyStreamServer

	context context.Context
	recv    func() (*Count, error)
	send    func(*Count) error

	received *queue.Circular[Count, *Count]
	stale    []*Count
	staleMu  sync.Mutex
	closed   *atomic.Bool
}

func (x *ExchangeNumbersServer) Context() context.Context {
	return x.context
}

func (x *ExchangeNumbersServer) Recv() (*Count, error) {
	return x.recv()
}

func (x *ExchangeNumbersServer) close() {
	x.staleMu.Lock()
	x.closed.Store(true)
	x.stale = x.received.Drain()
	x.staleMu.Unlock()
	x.received.Close()
}
func (x *ExchangeNumbersServer) Send(m *Count) error {
	return x.send(m)
}
func (x *ExchangeNumbersServer) CloseSend() error {
	r := Count{error: io.EOF, flags: SetCloseFlag(0, true)}
	return x.send(&r)
}

func (x *ExchangeNumbersServer) CloseAndSend(m *Count) error {
	m.flags = SetCloseFlag(m.flags, true)
	return x.send(m)
}

type Client struct {
	*frisbee.Client
	nextGetNumber         uint16
	nextGetNumberMu       sync.RWMutex
	inflightGetNumber     map[uint16]chan *Response
	inflightGetNumberMu   sync.RWMutex
	nextSendNumbers       uint16
	nextSendNumbersMu     sync.RWMutex
	inflightSendNumbers   map[uint16]chan *Response
	inflightSendNumbersMu sync.RWMutex
	nextGetNumbers        uint16
	nextGetNumbersMu      sync.RWMutex

	streamsGetNumbers     map[uint16]*GetNumbersClient
	streamsGetNumbersMu   sync.RWMutex
	nextExchangeNumbers   uint16
	nextExchangeNumbersMu sync.RWMutex

	streamsExchangeNumbers   map[uint16]*ExchangeNumbersClient
	streamsExchangeNumbersMu sync.RWMutex
}

func NewClient(tlsConfig *tls.Config, logger *zerolog.Logger) (*Client, error) {
	c := new(Client)
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.inflightGetNumberMu.RLock()
		if ch, ok := c.inflightGetNumber[incoming.Metadata.Id]; ok {
			c.inflightGetNumberMu.RUnlock()
			res := NewResponse()
			res.Decode(incoming.Content.B)
			ch <- res
		} else {
			c.inflightGetNumberMu.RUnlock()
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.inflightSendNumbersMu.RLock()
		if ch, ok := c.inflightSendNumbers[incoming.Metadata.Id]; ok {
			c.inflightSendNumbersMu.RUnlock()
			res := NewResponse()
			res.Decode(incoming.Content.B)
			ch <- res
		} else {
			c.inflightSendNumbersMu.RUnlock()
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		res := NewCount()
		err := res.Decode(incoming.Content.B)
		if err == nil {
			c.streamsGetNumbersMu.RLock()
			if stream, ok := c.streamsGetNumbers[incoming.Metadata.Id]; ok {
				c.streamsGetNumbersMu.RUnlock()
				err := stream.received.Push(res)
				if HasCloseFlag(res.flags) {
					stream.close()
				}
				if err != nil {
					return nil, 0
				}
			} else {
				c.streamsGetNumbersMu.RUnlock()
			}
		}
		return
	}
	table[13] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		res := NewCount()
		err := res.Decode(incoming.Content.B)
		if err == nil {
			c.streamsExchangeNumbersMu.RLock()
			if stream, ok := c.streamsExchangeNumbers[incoming.Metadata.Id]; ok {
				c.streamsExchangeNumbersMu.RUnlock()
				err := stream.received.Push(res)
				if HasCloseFlag(res.flags) {
					stream.close()
				}
				if err != nil {
					return nil, 0
				}
			} else {
				c.streamsExchangeNumbersMu.RUnlock()
			}
		}
		return
	}
	var err error
	if tlsConfig != nil {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	c.nextGetNumber = 0
	c.inflightGetNumber = make(map[uint16]chan *Response)
	c.nextSendNumbers = 0
	c.inflightSendNumbers = make(map[uint16]chan *Response)
	c.nextGetNumbers = 0
	c.streamsGetNumbers = make(map[uint16]*GetNumbersClient)
	c.nextExchangeNumbers = 0
	c.streamsExchangeNumbers = make(map[uint16]*ExchangeNumbersClient)
	return c, nil
}

func (c *Client) GetNumber(ctx context.Context, req *Request) (res *Response, err error) {
	ch := make(chan *Response, 1)
	p := packet.Get()
	p.Metadata.Operation = 10

	c.nextGetNumberMu.Lock()
	c.nextGetNumber += 1
	id := c.nextGetNumber
	c.nextGetNumberMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p)
	p.Metadata.ContentLength = uint32(len(p.Content.B))
	c.inflightGetNumberMu.Lock()
	c.inflightGetNumber[id] = ch
	c.inflightGetNumberMu.Unlock()
	err = c.Client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightGetNumberMu.Lock()
	delete(c.inflightGetNumber, id)
	c.inflightGetNumberMu.Unlock()
	packet.Put(p)
	return
}

func (c *Client) SendNumbers(ctx context.Context, req *Count) (*SendNumbersClient, error) {
	p := packet.Get()
	p.Metadata.Operation = 11

	c.nextSendNumbersMu.Lock()
	c.nextSendNumbers += 1
	id := c.nextSendNumbers
	c.nextSendNumbersMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p)
	p.Metadata.ContentLength = uint32(len(p.Content.B))
	err := c.Client.WritePacket(p)

	if err != nil {
		packet.Put(p)
		return nil, err
	}
	packet.Put(p)

	stream := SendNumbersClient{
		context: ctx,
		closed:  atomic.NewBool(false),
	}

	ch := make(chan *Response, 1)
	c.inflightSendNumbersMu.Lock()
	c.inflightSendNumbers[id] = ch
	c.inflightSendNumbersMu.Unlock()

	stream.recv = func() (res *Response, err error) {
		select {
		case res = <-ch:
			err = res.error
		case <-ctx.Done():
			err = ctx.Err()
		}
		c.inflightSendNumbersMu.Lock()
		delete(c.inflightSendNumbers, id)
		c.inflightSendNumbersMu.Unlock()
		return
	}
	stream.send = func(m *Count) error {
		p := packet.Get()
		p.Metadata.Operation = 11

		p.Metadata.Id = id

		m.Encode(p)
		p.Metadata.ContentLength = uint32(len(p.Content.B))
		err := c.WritePacket(p)
		if err != nil {
			packet.Put(p)
			return err
		}
		packet.Put(p)
		return nil
	}
	go func() {
		<-ctx.Done()
		c.inflightSendNumbersMu.Lock()
		delete(c.inflightSendNumbers, id)
		c.inflightSendNumbersMu.Unlock()
	}()
	return &stream, nil
}

type SendNumbersClient struct {
	context context.Context
	recv    func() (*Response, error)
	close   func()
	closed  *atomic.Bool

	send     func(*Count) error
	received *queue.Circular[Response, *Response]
}

func (x *SendNumbersClient) Send(m *Count) error {
	return x.send(m)
}

func (x *SendNumbersClient) CloseSend() error {
	r := Count{error: io.EOF, flags: SetCloseFlag(0, true)}
	return x.Send(&r)
}

func (x *SendNumbersClient) CloseAndRecv() (*Response, error) {
	r := Count{error: io.EOF, flags: SetCloseFlag(0, true)}
	x.Send(&r)
	return x.recv()
}

func (c *Client) GetNumbers(ctx context.Context, req *Request) (*GetNumbersClient, error) {
	p := packet.Get()
	p.Metadata.Operation = 12

	c.nextGetNumbersMu.Lock()
	c.nextGetNumbers += 1
	id := c.nextGetNumbers
	c.nextGetNumbersMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p)
	p.Metadata.ContentLength = uint32(len(p.Content.B))
	err := c.Client.WritePacket(p)

	q := queue.NewCircular[Count, *Count](100)
	stale := make([]*Count, 0)
	staleMu := sync.Mutex{}
	if err != nil {
		packet.Put(p)
		return nil, err
	}
	packet.Put(p)

	stream := GetNumbersClient{
		context:  ctx,
		closed:   atomic.NewBool(false),
		received: q,
	}
	c.streamsGetNumbersMu.Lock()
	c.streamsGetNumbers[id] = &stream
	c.streamsGetNumbersMu.Unlock()

	stream.recv = func() (*Count, error) {
		if stream.closed.Load() {
			staleMu.Lock()
			if len(stale) > 0 {
				var r *Count
				r, stale = stale[0], stale[1:]
				staleMu.Unlock()
				return r, nil
			}
			staleMu.Unlock()
			return nil, io.EOF
		} else if c.Closed() {
			stream.close()
		}

		readPacket, err := q.Pop()
		if err != nil {
			if stream.closed.Load() {
				staleMu.Lock()
				if len(stale) > 0 {
					var r *Count
					r, stale = stale[0], stale[1:]
					staleMu.Unlock()
					if errors.Is(r.error, io.EOF) {
						return nil, io.EOF
					}
					return r, nil
				}
				staleMu.Unlock()
			}
			return nil, io.EOF
		}
		if errors.Is(readPacket.error, io.EOF) {
			return nil, io.EOF
		}
		return readPacket, nil
	}
	stream.close = func() {
		if stream.closed.Load() {
			return
		}
		staleMu.Lock()
		stream.closed.Store(true)
		stale = q.Drain()
		staleMu.Unlock()
		q.Close()
	}
	go func() {
		<-ctx.Done()

		c.streamsGetNumbersMu.Lock()
		delete(c.streamsGetNumbers, id)
		c.streamsGetNumbersMu.Unlock()
	}()
	return &stream, nil
}

type GetNumbersClient struct {
	context context.Context
	recv    func() (*Count, error)
	close   func()
	closed  *atomic.Bool

	received *queue.Circular[Count, *Count]
}

func (x *GetNumbersClient) Recv() (*Count, error) {
	return x.recv()
}

func (c *Client) ExchangeNumbers(ctx context.Context, req *Count) (*ExchangeNumbersClient, error) {
	p := packet.Get()
	p.Metadata.Operation = 13

	c.nextExchangeNumbersMu.Lock()
	c.nextExchangeNumbers += 1
	id := c.nextExchangeNumbers
	c.nextExchangeNumbersMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p)
	p.Metadata.ContentLength = uint32(len(p.Content.B))
	err := c.Client.WritePacket(p)

	q := queue.NewCircular[Count, *Count](100)
	stale := make([]*Count, 0)
	staleMu := sync.Mutex{}
	if err != nil {
		packet.Put(p)
		return nil, err
	}
	packet.Put(p)

	stream := ExchangeNumbersClient{
		context:  ctx,
		closed:   atomic.NewBool(false),
		received: q,
	}
	c.streamsExchangeNumbersMu.Lock()
	c.streamsExchangeNumbers[id] = &stream
	c.streamsExchangeNumbersMu.Unlock()

	stream.recv = func() (*Count, error) {
		if stream.closed.Load() {
			staleMu.Lock()
			if len(stale) > 0 {
				var r *Count
				r, stale = stale[0], stale[1:]
				staleMu.Unlock()
				return r, nil
			}
			staleMu.Unlock()
			return nil, io.EOF
		} else if c.Closed() {
			stream.close()
		}

		readPacket, err := q.Pop()
		if err != nil {
			if stream.closed.Load() {
				staleMu.Lock()
				if len(stale) > 0 {
					var r *Count
					r, stale = stale[0], stale[1:]
					staleMu.Unlock()
					if errors.Is(r.error, io.EOF) {
						return nil, io.EOF
					}
					return r, nil
				}
				staleMu.Unlock()
			}
			return nil, io.EOF
		}
		if errors.Is(readPacket.error, io.EOF) {
			return nil, io.EOF
		}
		return readPacket, nil
	}
	stream.close = func() {
		if stream.closed.Load() {
			return
		}
		staleMu.Lock()
		stream.closed.Store(true)
		stale = q.Drain()
		staleMu.Unlock()
		q.Close()
	}
	stream.send = func(m *Count) error {
		p := packet.Get()
		p.Metadata.Operation = 13

		p.Metadata.Id = id

		m.Encode(p)
		p.Metadata.ContentLength = uint32(len(p.Content.B))
		err := c.WritePacket(p)
		if err != nil {
			packet.Put(p)
			return err
		}
		packet.Put(p)
		return nil
	}
	go func() {
		<-ctx.Done()

		c.streamsExchangeNumbersMu.Lock()
		delete(c.streamsExchangeNumbers, id)
		c.streamsExchangeNumbersMu.Unlock()
	}()
	return &stream, nil
}

type ExchangeNumbersClient struct {
	context context.Context
	recv    func() (*Count, error)
	close   func()
	closed  *atomic.Bool

	send     func(*Count) error
	received *queue.Circular[Count, *Count]
}

func (x *ExchangeNumbersClient) Recv() (*Count, error) {
	return x.recv()
}
func (x *ExchangeNumbersClient) Send(m *Count) error {
	return x.send(m)
}

func (x *ExchangeNumbersClient) CloseSend() error {
	r := Count{error: io.EOF, flags: SetCloseFlag(0, true)}
	return x.Send(&r)
}

func (x *ExchangeNumbersClient) CloseAndRecv() (*Count, error) {
	r := Count{error: io.EOF, flags: SetCloseFlag(0, true)}
	x.Send(&r)
	return x.recv()
}
